---
title: "joanna_post1"
description: |
  Description here
author:
  - name: Joanna Wright
    url: https://example.com/norajones
date: 05-08-2020
output:
  distill::distill_article:
    self_contained: false
---

This post describes examples of using iteration, parallel iteration, and writing functions in order to loop through a data set to extract information and create plots.

## Set-up

```{r setup }
knitr::opts_chunk$set(echo = TRUE)

```

<aside>
Libraries for this post
</aside>
```{r}
library(ggplot2)
library(tidyverse)
library(glue)
library(janitor)
library(purrr)
```


Loading the data. For details, see [Brock's post](link here).

```{r loading the data, results='hide'}

files <- list.files(here::here("data"),
                    full.names = TRUE)
files
d <- read_csv(files[1]) %>%
  clean_names()

```

## Task 1: Plotting mobility trends by country 

Let's say we want to create a separate plot for mobility trends in each country. For this example, let's start with one category - workplaces. First, we need to `group_by` country and `nest()` the rest of the data. This creates a list of tibbles, one for each country. I've called `head()` here so that we can see what the first few rows look like. 

```{r}
d %>%
  group_by(country) %>% 
  nest() %>%
  head()
```

Now we can use this as the input for our plots. `pmap()` is a variation of `map()` which allows us to apply a function to multiple vectors simultaneously.

```{r parallel iteration, workplaces mobility trends for each country}
plots_workplaces <- d %>%
  group_by(country) %>% 
  nest() %>% 
  mutate(plots = pmap(list(country, data),  
                      ~ggplot(..2, aes(date, workplaces)) +
                        geom_point() + 
                        geom_line()))

# test to see what a couple look like:
plots_workplaces$plots[1]
plots_workplaces$plots[2]
```

To add a unique title to each plot, use `{..1}` to select the 1st column, countries, to insert country names into the title. 

```{r adding unique title to each plot with country name}
# adding unique title: 
plots_workplaces1 <- d %>%
  group_by(country) %>% 
    nest() %>%
    mutate(plots = pmap(list(country, data),
    ~ggplot(..2, aes(date, workplaces)) +
      geom_point() + 
      geom_line() + 
      labs(title = glue("Mobility trends for workplaces in {..1}"),
           x = "Date", 
           y = "% change")))

# testing: 
plots_workplaces1$plots[1]
plots_workplaces1$plots[2]
```

Now that we've figured out how to loop through the data set to create plots that group by a variable (in this case, country), with an x-axis (in this case, time) and an outcome on the y-axis, let's generalize this with a function. Our function will have 4 arguments: the data frame, the y-axis variable, the x-axis variable, and the grouping variable. 

```{r}

# THIS WORKS, DON'T CHANGE FOR NOW
plot_fun <- function(df, outcome, x_axis, group_var) {
df %>%
  group_by({{group_var}}) %>% 
    nest() %>%
    mutate(plots = pmap(list({{group_var}}, data),
    ~ggplot(..2, aes(x_axis, outcome)) +
      geom_point() + 
      geom_line() + 
      labs(title = glue("Overal mobility trends in {..1}"),
           x = "Date", 
           y = "% change")))
}

```

Test it out on our data set, for mobility in parks: 
```{r}

plot_fun(d, parks, time, country)

```

NEED TO TROUBLESHOOT: 
```{r}

tmp_plots <- plot_fun(d, parks, time, country)

# When we assign object and try to view a plot, it doesn't work. Error message says object 'parks' not found. Why? 
tmp_plots$plots[2]

```

tmp_plots <- plot_fun(d, parks, time, country)

# But when we assign object and try to view a plot, it doesn't work. Why? 
tmp_plots$plots[[2]]

Test it out on another data set just to ensure that it indeed generalizes: (although we wouldn't use it this way because the lables are customized for this data set)
```{r}

plot_fun(gss_cat, tvhours, year, relig)

```

We can see that it's worked because it still gives us output with three columns: the grouping variable, and 2 nested lists, one with tibbles of plot data, and one with the plots we've created. 

Now that it works, we could use this function to explore mobility trends in our data set in different categories by simply exchanging our 'outcome' argument. For example, instead of 'parks' we could look at 'grocery_pharmacy': 
```{r}

plot_fun(d, grocery_pharmacy, time, country)

```

To see mobility trends by country as a whole, rather than per category, collapse category columns to create a new `total_mob` column, and then use the function we created. 
```{r}

d1 <- d %>%
  mutate(total_mob = rowSums(.[4:9]))

plot_fun(d1, total_mob, time, country)

```

Of course, running our plot function gives us a data frame with nested lists as the output, but does not show us the plots themselves. 
Below, I tried adding return() to the function to return the first plot. I also tried using deparse() to create label inputs, and using these in labs() to have each plot title refer to both the country and the outcome category displayed in that plot. 
(But the code below doesn't work yet.)

```{r}

plot_fun2 <- function(df, outcome, x_axis, group_var) {
   outcome_name <- deparse(substitute(outcome))
   country_name <- deparse(substitute(group_var))
   plots_tmp <- df %>%
  group_by({{group_var}}) %>% 
    nest() %>%
    mutate(plots = pmap(list({{group_var}}, data),
    ~ggplot(..2, aes(x_axis, outcome)) +
      geom_point() + 
      geom_line() + 
      labs(title = glue("Mobility trends in ", country_name, "for ", outcome_name),
           x = "Date", 
           y = "% change")))
   return(plots_tmp$plots[1])
}

# test:
plot_fun2(d, parks, time, country)
# returns an error message that object 'parks' not found. Why? 


```

## Task 2: How do infection rates relate to mobility trends, by country? 

Fitting a linear model to see how mobility changed as infection rate changed in each country: 

```{r results="hide"}

lm_by_country_lists <- d1 %>% 
  split(.$country) %>% # split into separate tbl for each country
  map(~lm(total_mob ~ total_cases, data = .)) # for each, fit lm
# Outputs a nested list

```

Extracting slopes: 

```{r }
slopes <- lm_by_country_lists %>%
    map(coef) %>%
    map_dbl(2)
slopes
```

## Things to work on:
Improve plot visualization 
Repeated use of code? 
