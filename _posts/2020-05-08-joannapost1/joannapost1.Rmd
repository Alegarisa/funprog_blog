---
title: "joanna_post1"
description: |
  Description here
author:
  - name: Joanna Wright
    url: https://example.com/norajones
date: 05-08-2020
output:
  distill::distill_article:
    self_contained: false
---

This post describes examples of iteration and parallel iteration to loop through a data set to extract particular information and create plots. It also demonstrates the use of writing functions.

## Set-up

```{r setup }
knitr::opts_chunk$set(echo = TRUE)

```

<aside>
Libraries for this post
</aside>
```{r}
library(ggplot2)
library(tidyverse)
library(glue)
library(janitor)
library(purrr)
```


Loading the data. For details, see [Brock's post](link here).

```{r loading the data, results='hide'}

files <- list.files(here::here("data"),
                    full.names = TRUE)
files
d <- read_csv(files[1]) %>%
  clean_names()

```

## Plot iteration: mobility trends by country 

Let's say we want to create a separate plot for mobility trends in each country. For this example, let's start with one category - workplaces. First, we need to `group_by` country and `nest()` the rest of the data. This creates a list of tibbles, one for each country. I've called `head()` here so that we can see what the first few rows look like. 

```{r}
d %>%
  group_by(country) %>% 
  nest() %>%
  head()
```

Now we can use this as the input for our plots. `pmap()` is a variation of `map()` which allows us to apply a function to multiple vectors simultaneously.

```{r parallel iteration, workplaces mobility trends for each country}
plots_workplaces <- d %>%
  group_by(country) %>% 
  nest() %>% 
  mutate(plots = pmap(list(country, data),  
                      ~ggplot(..2, aes(date, workplaces)) +
                        geom_point() + 
                        geom_line()))

# test to see what a couple look like:
plots_workplaces$plots[1]
plots_workplaces$plots[2]
```

To add a unique title to each plot, use `{..1}` to select the 1st column, countries, to insert country names into the title. 

```{r adding unique title to each plot with country name}
# adding unique title: 
plots_workplaces1 <- d %>%
  group_by(country) %>% 
    nest() %>%
    mutate(plots = pmap(list(country, data),
    ~ggplot(..2, aes(date, workplaces)) +
      geom_point() + 
      geom_line() + 
      labs(title = glue("Mobility trends for workplaces in {..1}"),
           x = "Date", 
           y = "% change")))

# testing: 
plots_workplaces1$plots[1]
plots_workplaces1$plots[2]
```

To apply the same strategy to see mobility trends by country as a whole, rather than per category, collapse category columns to create a new `total_mob` column, and then follow the code structure above to plot: 

```{r collapsing mobility across place categories}
d <- d %>%
  mutate(total_mob = rowSums(.[4:9]))

plots_allplaces <- d %>%
  group_by(country) %>% 
    nest() %>%
    mutate(plots = pmap(list(country, data),
    ~ggplot(..2, aes(date, total_mob)) +
      geom_point() + 
      geom_line() + 
      labs(title = glue("Overal mobility trends in {..1}"),
           x = "Date", 
           y = "% change")))

plots_allplaces$plots[1]
plots_allplaces$plots[10]
```

## How do infection rates relate to mobility trends, by country?   
Fitting a linear model to see how mobility changed as infection rate changed in each country: 

```{r results="hide"}
lm_by_country_lists <- d %>% 
  split(.$country) %>% # split into separate tbl for each country
  map(~lm(total_mob ~ total_cases, data = .)) # for each, fit lm
# Outputs a nested list
```

Extracting slopes: 

```{r }
slopes <- lm_by_country_lists %>%
    map(coef) %>%
    map_dbl(2)
slopes
```

We could also plot each lm: 

```{r}
 
# Using pmap? 

# By facet wrapping?   
ggplot(d, aes(x = total_cases, y = total_mob)) + 
  geom_point() +
  stat_smooth(method = "lm", col = "red") +
  facet_wrap(~ country)

```

## Writing functions: Example 1
Writing a function to extract coefs from linear models of change in mobility by change in infection rates. 
```{r}

# first: create new column "model" with lm data, total mobility by total cases 
mods_tmp <- d %>%
    group_by(country) %>%
    nest() %>%
    mutate(model = map(data, ~lm(total_mob ~ total_cases, data = .x)))
mods_tmp

# create function to return all coefficients: 
pull_coef <- function(model) {
    coefs <- coef(model)
    data.frame(coefficient = names(coefs),
               estimate    = coefs)
}

# now we can use that function to create new column coefs:  
mods_tmp %>%
    mutate(coefs = map(model, pull_coef))

# unnest coefs column to see data: 
mods_tmp %>%
    mutate(coefs = map(model, pull_coef)) %>%
    unnest(coefs)

# tidy up: 
mods_tmp %>%
    mutate(coefs = map(model, pull_coef)) %>%
    select(country, coefs) %>%
    unnest(coefs)

# further tidying, and arrange by intercept: 
mods_tmp %>%
    mutate(coefs = map(model, pull_coef)) %>%
    select(country, coefs) %>%
    unnest(coefs) %>%
    pivot_wider(names_from = "coefficient", 
                values_from = "estimate") %>% 
  arrange(`(Intercept)`)

```

## Writing functions: Example 2
Writing a function to apply a linear model of change in mobility by change in infection; then, iterate this function over each category, in each country.  

```{r}

# here's the new function. It has two arguments, "data" which supplies the dataset, and "outcome", which species the column of interest. In the body of the function, data[[outcome]] is a placeholder - we will specify which outcome we are interested in investigating in this regression.

lm_model <- function(data, outcome) {
  lm(data[[outcome]] ~ data[["total_cases"]])
}

# testing it on one category, "parks": 
lm_model(d, "parks") %>% 
  return()

# That works for one column at a time. But how would we iterate this function over all categories, in all countries? 
# To do this, we first need to pivot_longer so that there is one column for categories, and one for percent_change.

d1 <- d %>%
  pivot_longer(
    cols = 4:9,
    names_to = "category",
    values_to = "percent_change"
  )

# Then we can group by country and category, and loop through to apply the lm_model() function: 

d1_tmp <- d1 %>%
  group_by(country, category) %>%
  nest()

d1_tmp[["data"]]
 
map(d1_tmp, ~lm_model(.x, d1_tmp[["percent_change"]]))
# NEXT STEP - why is this not working? The problem is in the data argument... .x is not working 


```






