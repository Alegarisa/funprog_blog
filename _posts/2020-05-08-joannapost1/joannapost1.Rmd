---
title: "joanna_post1"
description: |
  Description here
author:
  - name: Joanna Wright
    url: https://example.com/norajones
date: 05-08-2020
output:
  distill::distill_article:
    self_contained: false
---

This post describes examples of iteration and parallel iteraction to loop through a data set to extract particular information and create plots. It also demonstrates the use of writing functions. 

I used these libraries: 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(ggplot2)
library(tidyverse)
library(glue)
library(janitor)
library(purrr)

```

Here's how I loaded the data. For details on loading data, see [Brock's post](link here).

```{r loading the data}

files <- list.files(here::here("data"),
                    full.names = TRUE)
files
d <- read_csv(files[1]) %>%
  clean_names()

```

### Plot iteration 
Let's say we want to create a separate plot for each country, for mobility trends in a particular category. For this example, we'll use parks. First, we need to `group_by` country and `nest()` the rest of the data. This creates a list of tibbles, one for each country. I've called `head()` here so that we can see what the first few rows look like. 

```{r}

d %>%
  group_by(country) %>% 
  nest() %>%
  head()

```

Now we can use this as the input for our plots. `pmap()` is a variation of `map()` which allows us to iteratively apply a function over multiple vectors simultaneously. 


```{r trying out parallel iteration, parks mobility trends}

plots1 <- d %>%
  group_by(country) %>% 
  nest() %>% 
  mutate(plots = pmap(list(country, data),
                      ~ggplot(..2, aes(date, parks)) +
                        geom_point() + 
                        geom_line()))

plots1$plots[1]
plots1$plots[2]

```

```{r adding unique title to each plot with country name}

# adding labels and unique title: 
plots_workplaces1 <- d %>%
  group_by(country) %>% 
    nest() %>%
    mutate(plots = pmap(list(country, data),
    ~ggplot(..2, aes(date, workplaces)) +
      geom_point() + 
      geom_line() + 
      labs(title = glue("Mobility trends for workplaces in {..1}"),
           x = "Date", 
           y = "% change")))

# testing: 
plots_workplaces1$plots[1]
plots_workplaces1$plots[2]

```

```{r collapsing mobility across place categories}

# Let's collapse across place categories to get total mobility for each day, in each country:
d <- d %>%
  mutate(total_mob = rowSums(.[4:9]))

# take a quick look at total mobility data for one country, just to make sure the rowSums worked like we'd expect: 
d %>% 
  filter(country == "Argentina") %>%
  ggplot(aes(date, total_mob)) +
  geom_point()

plots_allplaces <- d %>%
  group_by(country) %>% 
    nest() %>%
    mutate(plots = pmap(list(country, data),
    ~ggplot(..2, aes(date, total_mob)) +
      geom_point() + 
      geom_line() + 
      labs(title = glue("Overal mobility trends in {..1}"),
           x = "Date", 
           y = "% change")))

plots_allplaces$plots[1]
plots_allplaces$plots[10]

```

```{r how mobility relates to infection rates}

# what does the relationship between total mobility and total cases look like?

plot(total_cases ~ total_mob, data = d, col=2)

# fitting linear model:
lm_total_mob <- lm(total_mob ~ total_cases, data = d)

# view output:
summary(lm_total_mob)

# total mobility by country: 
d %>%
  ggplot(aes(date, total_mob)) +
  geom_line() +
  facet_wrap(~ country)

# one way to plot lm, this is for all countries together: 
plot(total_mob ~ total_cases, data = d)
abline(lm_total_mob)

# looking at the lm by country: 
ggplot(d, aes(x = total_cases, y = total_mob)) + 
  geom_point() +
  stat_smooth(method = "lm", col = "red") +
  facet_wrap(~ country)

```

```{r fit separate linear models by country, extracting }

# returns nested lists: 
lm_by_country_lists <- d %>% 
  split(.$country) %>% 
  map(~lm(total_mob ~ total_cases, data = .))

# extracting r squared 
lm_by_country_lists %>% 
  map(summary) %>% 
  map_dbl(~.$r.squared) # tilda and . to loop through each country list and extract r squared

# or could extract r squared by naming: 
lm_by_country_lists %>% 
  map(summary) %>% 
  map_dbl("r.squared")

# OR, a different approach, returns data frame: 
lm_by_country_df <- split(d, d$country) %>%
     map_df(~lm(total_mob ~ total_cases, .x) %>%
              broom::tidy(),
            .id = "year")

# summary of data frame:  
lm_by_country_df %>%
  map(summary)

```


