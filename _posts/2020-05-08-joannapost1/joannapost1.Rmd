---
title: "joanna_post1"
description: |
  Description here
author:
  - name: Joanna Wright
    url: https://example.com/norajones
date: 05-08-2020
output:
  distill::distill_article:
    self_contained: false
---

This post describes examples of iteration and parallel iteration to loop through a data set to extract particular information and create plots. It also demonstrates the use of writing functions.

## Set-up

```{r setup }
knitr::opts_chunk$set(echo = TRUE)

```

<aside>
Libraries for this post
</aside>
```{r}
library(ggplot2)
library(tidyverse)
library(glue)
library(janitor)
library(purrr)
```


Here's how I loaded the data. For details on loading data, see [Brock's post](link here).

```{r loading the data, results='hide'}

files <- list.files(here::here("data"),
                    full.names = TRUE)
files
d <- read_csv(files[1]) %>%
  clean_names()

```

## Plot iteration: mobility trends by country 

Let's say we want to create a separate plot for mobility trends in each country. For this example, let's start with one category - workplaces. First, we need to `group_by` country and `nest()` the rest of the data. This creates a list of tibbles, one for each country. I've called `head()` here so that we can see what the first few rows look like. 

```{r}

d %>%
  group_by(country) %>% 
  nest() %>%
  head()

```

Now we can use this as the input for our plots. `pmap()` is a variation of `map()` which allows us to apply a function to multiple vectors simultaneously.

```{r parallel iteration, workplaces mobility trends for each country}

plots_workplaces <- d %>%
  group_by(country) %>% 
  nest() %>% 
  mutate(plots = pmap(list(country, data),  
                      ~ggplot(..2, aes(date, workplaces)) +
                        geom_point() + 
                        geom_line()))

# test to see what a couple look like:
plots_workplaces$plots[1]
plots_workplaces$plots[2]

```

To add a unique title to each plot, use `{..1}` to select the 1st column, countries, to insert country names into the title. 

```{r adding unique title to each plot with country name}

# adding labels and unique title: 
plots_workplaces1 <- d %>%
  group_by(country) %>% 
    nest() %>%
    mutate(plots = pmap(list(country, data),
    ~ggplot(..2, aes(date, workplaces)) +
      geom_point() + 
      geom_line() + 
      labs(title = glue("Mobility trends for workplaces in {..1}"),
           x = "Date", 
           y = "% change")))

# testing: 
plots_workplaces1$plots[1]
plots_workplaces1$plots[2]

```

To apply the same strategy to see mobility trends by country as a whole, rather than per category, collapse category columns to create a new `total_mob` column, and then follow the code structure above to plot: 

```{r collapsing mobility across place categories}

d <- d %>%
  mutate(total_mob = rowSums(.[4:9]))

plots_allplaces <- d %>%
  group_by(country) %>% 
    nest() %>%
    mutate(plots = pmap(list(country, data),
    ~ggplot(..2, aes(date, total_mob)) +
      geom_point() + 
      geom_line() + 
      labs(title = glue("Overal mobility trends in {..1}"),
           x = "Date", 
           y = "% change")))

plots_allplaces$plots[1]
plots_allplaces$plots[10]

```

## How do infection rates relate to mobility trends, by country?   
Fitting a linear model to see how mobility changed as infection rate changed in each country: 

```{r results="hide"}

lm_by_country_lists <- d %>% 
  split(.$country) %>% # split into separate tbl for each country
  map(~lm(total_mob ~ total_cases, data = .)) # for each tbl, fit lm
# Outputs a nested list
```

Extracting slopes: 

```{r }
slopes <- lm_by_country_lists %>%
    map(coef) %>%
    map_dbl(2)
slopes
```

We could also plot each lm: 

```{r}
 
# Using pmap? 

# By facet wrapping?   
ggplot(d, aes(x = total_cases, y = total_mob)) + 
  geom_point() +
  stat_smooth(method = "lm", col = "red") +
  facet_wrap(~ country)

```

### Writing functions: an example
Writing a function to extract coefs from linear models of change in mobility by change in infection rates. 

```{r}

# first: create new column "model" with lm data, total mobility by total cases 
mods_tmp <- d %>%
    group_by(country) %>%
    nest() %>%
    mutate(model = map(data, ~lm(total_mob ~ total_cases, data = .x)))
mods_tmp

# create function to return all coefficients: 
pull_coef <- function(model) {
    coefs <- coef(model)
    data.frame(coefficient = names(coefs),
               estimate    = coefs)
}

# now we can use that function to create new column coefs:  
mods_tmp %>%
    mutate(coefs = map(model, pull_coef))

# unnest coefs column to see data: 
mods_tmp %>%
    mutate(coefs = map(model, pull_coef)) %>%
    unnest(coefs)

# tidy up: 
mods_tmp %>%
    mutate(coefs = map(model, pull_coef)) %>%
    select(country, coefs) %>%
    unnest(coefs)

# further tidying, and arrange by intercept: 
mods_tmp %>%
    mutate(coefs = map(model, pull_coef)) %>%
    select(country, coefs) %>%
    unnest(coefs) %>%
    pivot_wider(names_from = "coefficient", 
                values_from = "estimate") %>% 
  arrange(`(Intercept)`)

# now, let's use the function we created to pull coefs for each mobility category, not just total_mob. 


```





```{r playing w/code, echo=FALSE, results='hide'}

# OR, a different approach, returns data frame: 
lm_by_country_df <- split(d, d$country) %>%
     map_df(~lm(total_mob ~ total_cases, .x) %>%
              broom::tidy(),
            .id = "year")

# summary of data frame:  
lm_by_country_df %>%
  map(summary)

```




